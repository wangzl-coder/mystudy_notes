#if 0
    内核编程特点（对比应用层编程）：
        1 不能访问C库也不能访问标准C头文件
        2 必须使用GUN C
        3 缺乏用户空间得内存保护机制
        4 难以执行浮点运算
        5 内核给每个进程只有一个很小的定长堆栈
        6 由于内核支持异步中断，抢占和SMP，因此必须时刻注意同步和并发
        7 考虑可移植性

    无libc库或标准头文件：
        1 依赖悖论，效率和内存低效，大部分常用C库函数在内核中得到实现如lib/string.c
        2 头文件：基本头文件include（<linux/inotify.h>）， 架构相关arch/<architecture>/include/asm下(<asm/ioctl.h>)
        3 printk, 格式化字符串到日志缓冲区，优先级printk(KERN_ERR "this is an error!\n")

    GUN C:
        1 并不完全符合ANSI C标准，涵盖ISO C99标准和GUN C扩展特性
        2 扩展：
            （1）内联（inline）函数：在所调用位置展开，消除函数调用和返回的开销。适用于长度短时间要求高的地方，需使用
            static 关键字，并用inline限定，一般在头文件定义：
                    static inline void wolf(unsigned long tail_size)

            （2）内联汇编：C函数中嵌入汇编指令
                unsigned int low, high;
                asm volatile("rdtsc" : "=a" (low), "=d" (high));

            （3）分支声明：gcc内建一条指令用于优化，在一个条件经常出现，或者很少出现时，编译器可以进行优化，内核将其封装成了
                宏，比如likely()和unlikely():
                    认为error绝大多数都会为0：
                        if(unlikely(error)) {
                            /* ... */
                        }
                    
                    认为success通常不会为0：
                        if(likely(success)) {
                            /* ... */
                        }

    没有内存保护机制：
        用户程序访问非法地址：内核会发现错误，并发送SIGSEGV信号。内核中发生的内存错误会导致oops。内核的内存不分页.

    浮点数：
        用户空间：模式转换，
        内核并不能完美支持浮点操作

    容积小而固定的栈：
        
    同步和并发：
        内核很容易产生竞争条件：
            (1) Linux是抢占多任务操作系统，内核必须和调度的任务同步
            (2) Linux内核支持对称多处理器系统(SMP),两个或以上的处理器执行内核代码可能会同事访问共享的一个资源
            (3) Linux内核可以抢占，内核中正在执行的代码可能被另一段代码抢占，从而导致同时访问相同的资源
        常用的解决竞争的方法： 自旋锁和信号量

    可移植的重要性
        把体系结构相关的代码从内核代码树的特定目录中适当的分离出来。
        字节序，64位对其，不假定字长和页面长度等准则

#endif
