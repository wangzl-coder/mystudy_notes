#if 0
    抢占和上下文切换
        
        上下文切换：可执行进程到另一个可执行进程的切换，由函数context_switch()负责（由schedule()函数调用），其
            完成两项基本工作：
            （1）调用switch_mm(),将虚拟内存从上一个进程映射切换到新进程
            （2）调用switch_to(),负责从上一个进程的处理器状态切换到新进程处理器状态，包括保存，恢复栈信息和寄存器
                信息，还有其他状态信息。

        抢占：内核检查need_resched标识来确认是否需要重新执行一次调度

        1 用户抢占：内核即将返回用户空间（中断处理程序中返回或者系统调用中返回）时，检测到need_resched被设置，此时发生用户抢占。

        2 内核抢占：Linux完整支持内核抢占，在没有持有锁的情况下，内核可以进行抢占，锁是非抢占区域的标志，实现：
            （1）为每个进程的thread_info引入preempt_count计数器，初始值0，使用锁时自增，释放锁时自减。当数值为0时，内核可以抢占。
            释放锁的代码也会检查need_resched并调用schedule()。有些内核代码需要允许或禁止内核抢占。内核抢断发生在：
            a：中断处理程序正在执行，且返回内核空间之前
            b：内核代码再一次具有可抢占性的时候
            c：内核任务显式调用schedule()
            d：内核中的任务阻塞
#endif
