#if 0
1 内核表示IO的数据结构：
    三种数据结构表示打开的文件，决定了不同进程之间的文件共享
    a.每个进程在进程表中有一个记录项，记录项中包含一张打开的文件描述符表，
        每个文件描述符占用一项，其包含文件描述符标志和指向文件表项的指针。
    b.内核为所有打开的文件维持一张文件表（对于一个进程），每个文件表包含文件状态标志（读，
        写，添写，同步和非阻塞等），当前文件偏移量和指向该文件v节点表项的指针
    c.每个文件都有v节点结构，v节点包含了文件类型以及各种操作的函数指针以及i节点。
        此信息是从磁盘读入内存，i节点包含文件所有者，文件长度，所在设备以及文件
        实际数据块在磁盘上所处位置的指针等（备注：linux没有v节点，只有独立与文件系统的
        i节点和依赖于文件系统的i节点）。

2：文件描述符标志和文件状态标志的区别：
    前者：只作用与一个进程的一个描述符
    后者：作用于所有指向该文件表项的进程的所有描述符

3：同步问题：
    每个进程都有自己的文件表项，用来标识自己当前的文件偏移量，导致现象：
    a.多进程对同一文件同时的读操作相对独立，可以正常操作
    b.多进程对同一文件同时的写操作将会造成偏移量同步问题，造成写覆盖。

4：原子操作（atomic operation）
    a.lseek+write追加写的不安全性：进程A-->lseek,进程B-->lseek，进程B-->write,进程A-->write，
        结果：A写覆盖B
    b.安全操作：O_APPEND,每次写之前都将进程的当前偏移量移到文件末尾。
    c.pread,pwrite，相当于lseek+read(write)，但期间不能被中断
    d.创建文件：O_CREAT | O_EXCL(创建的文件存在是将失败返回)，不能使用open+create机制

5：dup和dup2
    a. 用法：复制一个现存的文件描述符
        int dup(int oldfd); int dup2(int oldfd, int newfd)
        dup:返回可用最小的新描述符id，
        dup2：用newfd指定新描述符数值，如果newfd已经打开，先将其关闭。如果oldfd == newfd,则返回newfd而不关闭。
    b.复制的文件描述符共享一个文件表项，即共享同一文件状态和当前文件偏移量

#endif
